Мне не удалось найти ни одной функции, на которой я смог бы потренироваться. Но чтобы это занятие для меня не прошло впустую, я вычленил ключевые мысли из материала и поработал с каждой по отдельности, приведя показательные примеры, дополнив их своими комментариями и размышлениями.

#### Тезисы

Способы снижения цикломатической сложности

1) else, заменяется return'ом;
2) Использовать ad-hoc полиморфизм (перегрузку функций по типам аргументов и их количеству);
3) Использовать параметрический полиморфизм (дженерики);
4) Автомат состояний. В нем работа методов зависит от текущего состояния, а методы меняют это состояние по допустимым переходам;
5) Multiple dispatch, который крайне похож на ad-hoc. Допускает определить множество функций, различающихся только типами аргументов;
6) Табличная логика. По идее реализуется с помощью словаря, иными словами, на входное значение из допустимого диапазона находится своя реализация;
7) В каждом условии может проверяться лишь один аргумент функции.
8) Следует избавляться от else'ов и цепочек else if'ов, if'ов, вложенных в другие if'ы, а также циклов, вложенных в if'ы. if внутри цикла разрешается использовать только для управления работой цикла, для выхода из функции или генерации исключения;


***

## №1 Избавляемся от else с помощью return

Суть и пользу от применения этого подхода я еще почувствовал при работе над первыми двумя курсами по АСД. С тех пор я всегда применяю именно этот подход. А к тому же очень редко применяю else, пожалуй, только лишь для того, чтобы сделать код более похожим на речь.

``` c++
// Было

bool even_or_odd(int number) {
    if (number % 2 == 0){
        return true;
    }
    else {
        return false;
    }
}
```

``` c++
// Стало

bool even_or_odd(int number) {
    if (number % 2 == 0){
        return true;
    }
    return false;
}
```

Уже лучше, но можно пойти и еще дальше, сделав так:

``` c++
bool even_or_odd(int number) {
    return (number % 2 == 0);
}
```

Для реализации на python можно добавить проверку типа. Такая проверка должна располагаться как можно ближе к началу тела функции.

``` python
from math import abs


def even_or_odd(number):
# Такая реализация будто бы позволяет применить Multiple Dispatch в python. В функию может поступить как
# 2.0, так и 2, и в обоих случаях функция сработает. Что произойдет, если в функцию поступит
# 2.00000000000002 лучше не задумыватьс.
    if abs(int(number) - number) > 0.00000000000001:
        raise ValueError("number не является целым числом")

    return number % 2 == 0
```

## №2 Применение ad-hoc полиморфизма

Применение ad-hoc полиморфизма позволяет возложить заботы на компилятор, сняв их с плеч программиста. Такой вид полиморфизма заключается в возможности объявления нескольких функций с одинаковыми названиями и разным числом аргументов. Например, возьмём придуманную функцию, которая скачивает файл и сохраняет его по указанному пути.

``` python
def download_file(url, path):
    file = downloader.download(url)

    if path:
        saver.save(file, path)
```

Эту функцию можно улучшить, можно избавиться от if вовсе:

``` python
def download_file(url, path='.'):
    file = downloader.download(url)
    saver.save(file, path)
```

Таким образом применяется в действие ad-hoc полиморфизм, если в функцию был передан аргумент path- то он заменяет собой текущую директорию.

**Рассмотрим другой пример. Пусть есть функция, которая получает список именованных аргументов. Допустим, обработчик формы, которую заполняет на клиентской стороне пользователь. Причем, пользователь способен сам добавить в эту форму ключей.**

``` python
def user_answers_processor(answers):
    # обработка
```

**Возможна реализация, принимающая в себя некий объект класса Form, внутри которого содержится словарь с данными, которые ввёл пользователь. Если функция будет делать что- то еще помимо работы с этим словарем- то избыточно отправлять в неё объект Form целиком, в обратном случае функция становится перегруженной. Куда правильнее отправить в функцию**

ad-hoc полиморфизм крайне бы помог в реализации класса-сортировщика. Такой класс бы обладал возможностью проводить сортировку по различным структурам данных.

``` csharp
public class Sorter<T>
{
    public Sorter() {
        ...
    }

    public void Sort(T collection)
    {
        if (collection is LinkedList)
        {
            Console.WriteLine("Sorting LinkedList");
            // ...
        }
        if (collection is Tree)
        {
            Console.WriteLine("Sorting Tree");
            //...
        }
    }
}
```

Чтобы избавиться от цепочки if'ов, следует определить несколько методов с одинаковым именем, но разными параметрами

``` csharp
public class Sorter<T>
{
    public Sorter() {
        ...
    }

    public void Sort(LinkedList collection)
    {
        Console.WriteLine("Sorting LinkedList");
            // ...
    }

    public void Sort(Tree collection) {
        Console.WriteLine("Sorting Tree");
        //...
    }

}
```

Никаких if'ов, дело сделано. Красиво получилось по той причине, что для каждой из структур применяется уникальный метод сортировки.

## №3 Применение параметрического полиморфизма

Параметрический полиморфизм можно понимать аналогично "утиной" типизации из Python. Например, предыдущую задачу можно решить и по другому:

``` python
class Sorter:
    def __init__(self):
        pass

    def Sort(collection):
        collection.sort()
```

Теперь класс сортировщик вызывает метод сортировки у любой коллекции, которая к нему попала. Ответственность за реализацию этого метода остается на классе-коллекции. Если такого метода коллекция не предоставляет, то следует реализовать класс-обертку, реализующий недостающий метод сортировки.

## №4 Применение автомата состояний

Применение автомата состояний упрощает жизнь в условиях наличия объекта, состояний, возможности у объекта по этим состояниям переходить и наличии ограничений на переходы между состояниями. Например, удостоверение пользователя, по которому он проходит аутентификацию, может быть:
- активным;
- истекло количество использований;
- заблокированным;
- требующим проверки;
- архивированным;
- и все, что угодно еще.

Ограничения представляют собой запрет на переходи из некоторых состояний в другие, допустим из состояния "архивированное" в состояние "активное" перейти нельзя.

На обывательском уровне такая задачка решается наворачиванием цепочек if-else'ов с цикломатической сложностью, стремящейся к кризису среднего возраста уж точно (примерно 30). реализовать такую штуку в первый раз- посильная задача, но если возникнет необходимость что- то в ней поменять- лучше иметь готовое заявление на увольнение, либо лишние волосы, выпадение которых спровоцирует внесение изменений в ворох if'ов.

А вот применение автомата состояний позволяет фактически декларативно описать систему.

В python существует библиотека transitions модуля Machine, а реализовать описанную выше схему можно так:

``` python
from transitions import Machine

class UserCertificate: # класс удостоверение
    pass

cert_1 = UserCertificate()

# все состояния
states = [
    'active',
    'no number of uses',
    'blocked',
    'needs to be checked',
    'archived',
]

transitions = [

    # переход из активного в заблокированное
    {'trigger': 'ban', 'source': 'active', 'dest': 'blocked'},

    # вроде бы можно сделать и так: один и тот же тигер и конечное состояние,
    # но начальные состояние разные
    {'trigger': 'archive', 'source': 'active', 'dest': 'archived'},
    {'trigger': 'archive', 'source': 'active', 'dest': 'archived'},
    # и так далее
]

machine = Machine(cert_1, states=states, transitions=transitions, initial='no number of uses')

# теперь у объекта есть state
# cert_1.state

cert_1.trigger('ban') # вызов тригера для перехода
```

## №5 Multiple Dispatch

Multiple Dispatch в ООП языках похож на смесь ad-hoc и параметрического  полиморфизма. Он заключается в возможности определить множество функций, чьи сигнатуры различаются лишь типами параметров.

## №6 Применение табличной логики

Такой прием носит название "табличный" потому что для его осуществления применяется таблица из базы данных. Изменение записей в таблицу позволяет не пересобирать проект каждый раз, поскольку действия, которые требуются совершить над данными, прописаны в таблице БД, где их можно изменять прямо во время работы проекта. Применение табличной логики само по себе не столько позволяет снизить цикломатическую сложность кода, сколько представляет собой аналог перегрузки методов, полиморфизма.

## №7 и №8 Практики

Я рискну назвать указанные практики практическими, не столько снижающими цикломатическую сложность, сколько повышающими читаемость кода и простоту его обслуживания.
