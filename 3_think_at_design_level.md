Я выполнил поставленное задание, проведя работу над реализацией структуры данных
Queue.


Первым делом, следуя методикке TDD, описал тесты для структуры Queue:

``` python
from queue import Queue


"""
Действуя по принципам TDD, первым делом необходимо написать тесты. Пока что размышлений на уровне спецификации программы я не веду. Придумываю тесты из головы.
"""


def test_queue_creation():
    """
    Тест должен проверить, что объект создался верно с верным начальным    состоянием.    """    q = Queue()

    assert type(q) is Queue
    assert q.size() == 0
    assert len(q._queue) == 0


def test_queue_enqueue():
    """
    Тест проверяет, что в хвост очереди и правда заносится элемент.    """    q = Queue()

    value = "Info"
    value_id = id(value)

    q.enqueue(value)  # запихнуть элемент в хвост очереди

    # Тут уже могут начаться проблемы. Если сейчас голова очереди всегда    # находится по индексу 0, то кто гарантирует это в будущем? В этом тесте    # складывается ситуация, в которой код следует за тестом. После того как    # будет переписан код, тест начнет следовать за кодом.    #    # <Программное обеспечение -- это область, в которой мы принимаем решения,    # которые нельзя отменить и которые должны поддерживаться вечно.>
    assert q._queue[0] is value

    another_value = "Other info"

    q.enqueue(another_value)

    assert q._queue[0] is value

    assert q._queue[-1] is another_value


def test_queue_dequeue():
    """
    Тест проверяет, что из головы очереди был удален элемент.    """
    q = Queue()

    value = "Info"

    q.enqueue(value)

    assert q.size() == 1

    same_value = q.dequeue()

    assert q.size() == 0

    # Ситуация аналогична тесту `test_queue_add`.
    assert same_value is value


def test_queue_get():
    """
    Тест проверяет, что из головы очереди был получен элемент, но не удален.    """
    q = Queue()

    value = "Info"

    q.enqueue(value)

    assert q.size() == 1

    same_value = q.get()

    assert q.size() == 1

    assert same_value is value


def test_queue_size():
    q = Queue()

    assert q.size() == 0

    q.enqueue(1)

    assert q.size() == 1

    q.dequeue()

    assert q.size() == 0


def test_queue_correct():
    """
    Этот тест должен проверить, что порядок элементов в очереди сохраняется    несмотря на производимые операции над очередью. Поскольку реализация    теста не сложная, но муторная, не буду её выполнять.    """    pass
```

Я полагаю, что думаю о программе на третьем уровне. Ведь сам код структуры данных я же еще не пишу, а лишь рассуждаю о ней в формате unit-тестов, делаю её спецификацию. Но это ошибка. Как было замечено в занятии, мне кажется, что я так поступаю, unit-тесты представляют собой попытку подумать о программе на третьем уровне, но в рамках второго. В простонародье - "костыль".

Мои тесты никак не отражают спецификацию, да и самой спецификации нет. Особо явно это видно в тестах, основывающихся на там, что голова очереди находится по индексу 0 внутреннего хранилища. То есть тест опирается сам на себя, а код следует за этим тестом. Если изменить реализацию- придется менять тест, а в этом случае уже он будет следовать за кодом.

Но что, если первым делом описать спецификацию? Например, на основе АТД:

``` python
# abstract class Queue<T>
#
#     // конструктор
#     // постусловие: создана пустая очередь
#     public Queue<T> Queue();
#
#     // команды
#     // постусловие: в хвост очереди добавлен новый элемент
#     public void enqueue(T value);
#
#     // предусловие: очередь не пуста;
#     // постусловие: из головы очереди удалён элемент
#     public void dequeue();
#
#     // запросы
#     // предусловие: очередь не пуста
#     public T get(); // получить элемент из головы очереди;
#
#     public int size(); // текущий размер очереди
#
#     // запросы статусов (возможные значения статусов)
#     public int get_dequeue_status(); // успешно; очередь пуста
#     public int get_get_status(); // успешно; очередь пуста  ```
```

Затем уже следует описать тесты, основываясь именно на спецификации. Замечу, что в ней ни слова не указано про индексы, внутренние хранилища и прочее. Есть лишь относительно высоко абстрактный интерфейс. Следовательно, в тестах мне дозволяется "дергать" исключительно его.

"Реализация может меняться сколь угодно много раз, но интерфейс остается неизменен"- эту цитату я видел слишком много раз, чтобы запомнить, кому она принадлежит, но это именно этот случай.

Мне конечно интересно посмотреть в тестах, как меняются состояния флагов `_last_deque_succed` и `_last_get_succeed`, но обращение к ним в тестах моментально приведет к тому, что мои тесты начнут следовать за кодом. А дальнейшее развитие проекта наверняка приведет к тому, что придется тесты переписывать, а это действие имеет некий негативный окрас.

Например, тест `test_queue_enqueue` можно переписать следующим образом:

``` python
def test_queue_enqueue():
    q = Queue()

    value1 = "1"
    value2 = "2"
    value3 = "3"

    q.enqueue(value1)
    assert q.get() is value1

    q.enqueue(value2)
    assert q.get() is value1

    q.enqueue(value3)
    assert q.get() is value1

    q.dequeue()
    assert q.get() is value2

    q.dequeue()
    assert q.get() is value3

    q.dequeue()
    assert q.get() == 1
```

Теперь у теста нет никакой привязки к внутренней реализации структуры данных. А вместо этого тест опирается на спецификацию (предполагается, что и значение 1 прописано в спецификации).
