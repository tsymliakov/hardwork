# Ясный код на более продвинутом уровне


## 1. Уровень реализации

В одном из постов для блога я описывал создание программки, которая могла бы писать в rsyslog, в сокет, который он прослушивает. Вот кусок её исходного кода:

``` python
import socket
import time
import random
import sys


DEFAULT_RSYSLOG_SOCKET = '/dev/log'


def get_connected_client(socket_path):
    client = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    client.connect(socket_path)
    return client


def send_to_socket(client, infinite=False):
    while True:
        message = f'Message from python {random.randint(1, 100)}'
        client.send(message.encode())

        if not infinite:
            break

        time.sleep(2)

    client.close()


if __name__ == '__main__':
    path_in_list = sys.argv[1:2]

    if not path_in_list:
        print('Path to socket is needed')
        sys.exit(1)

    path = path_in_list[0]

    client = get_connected_client(DEFAULT_RSYSLOG_SOCKET)
    send_to_socket(client)

```

С этим кодом есть проблема. Из- за неверного формата сообщения, rsyslog отрезает два (или четыре) байта от передаваемого сообщения. Тем самым происходит вот какая беда: на уровне логики выходит, что приложение ворует два (или 4) байта у пользователя, на уровне реализации проблема не ясна, ну потому что с виду код выглядит нормально. А вот на уровне реализации уже rsyslog'а становится ясно, он пытается вычленить особое поле PRIVAL из сообщения, а так как его нет в сообщение- под горячую руку попадают 2 (или всё таки 4) первых байта сообщения.

Исправим эту ситуацию:

``` python
FACILITY_LOCAL_USE_0 = 16
SEVERITY_DEBUG = 7

message = f'<{FACILITY_LOCAL_USE_0 * 8 + SEVERITY_DEBUG}>Message from python {random.randint(1, 100)}'
```

Таким образом rsyslog получит данные, которые так настойчиво пытался распарсить и тем самым, приложение отработает соответственно ожиданиям пользователя.


(Вот тут я заметил, что "1 Уровень реализации" это тема занятия, а не задание :)
Но ничего, пусть будет)


## 1.1 Методы, которые используются только в тестах (подумайте, как от них избавиться)


Такого мне не встречалось ввиду не самой большой практики. Но тимлид, который сидит рядом со мной, постоянно встречает код в продукте, который никогда не исполняется. В основном он его либо удаляет, либо чинит и код начинает вызываться.

Я считаю, что если метод используется только в тестах, значит этот код следует удалить, но сперва надо убедиться, что метод и правда используется исключительно в тестах. Естественно, сделать верный вывод можно только в отношении приватных методов. Сайт refactoring guru солидарен со мной в этом вопросе, там еще забавные "методики" рефакторинга предлагаются по этому поводу:

```
Проблема

Параметр не используется в теле метода.
```

```
Решение

Удалите неиспользуемый параметр.
```

В общем- то и тесты вслед за методами должны быть уделены.

Но есть оговорка, если метод предназначен для настройки тестового окружения или приводит программу в некое состояние, требуемое тестированием, то такой метод, конечно, вряд ли следует удалять. В общем, **нужно исходить из ситуации**.


## 1.2 Цепочки методов


У меня такого когда нет, к сожалению или к счастью, зато я регулярно сталкиваюсь вот с такой цепочкой вызовов:

``` python
LOG.info(msg) -- (logger.info(msg)) -> logger.log(level=info, msg) -> logger._log(level=info, msg)
```

Если это так сделано, то зачем- то оно сделано, а может быть это просто неверное решение, которое тянется до сих пор. Причем, это лишь верхушка айзберга, далее, чтобы всего- то залогировать сообщение, создается запись через `logger.makeRecord()`, затем вызывается метод `logger.handle(record)`, который начинает вызывать обработчики, присоединенные к логеру.

К последующим вызовам у меня нет претензий, у меня есть претензия к тому, что метод `_log` приватный, а чтобы добраться до него, нужно пройти через два вызова. Причем, публичный метод log осуществляет всего лишь проверку severity ну и так, по мелочи:

``` python
def log(self, level, msg, *args, **kwargs):
    """
    Log 'msg % args' with the integer severity 'level'.
    To pass exception information, use the keyword argument exc_info with
    a true value, e.g.
    logger.log(level, "We have a %s", "mysterious problem", exc_info=True)
    """
    if not isinstance(level, int):
        if raiseExceptions:
            raise TypeError("level must be an integer")
        else:
            return
    if self.isEnabledFor(level):
        self._log(level, msg, args, **kwargs)
```

В общем, можно два уровня вложенности исключить: `LOG.info()` и `logger.log(level=...)` безболезненно. А засчёт этого еще и строк 100 кода уберется, ибо помимо метода `info()` есть еще 6 абсолютно аналогичных, азличающихся только уровнем логирования.


## 1.3 У метода слишком большой список параметров

``` python
def makeRecord(self, name, level, fn, lno, msg, args, exc_info,
                   func=None, extra=None, sinfo=None):
```

Вот такой вот список параметров у функции стандартной библиотеки питона. Названия аргументов `fn` и `lno` хоть и вызывают недоумение, но все же очевидно! `fn` - конечно же function, а `lno` - это "Latvian National Opera". Но подождите, а зачем второй аргумент `func=None`?

Следовало определить класс Record, который бы и представлял собой запись для логирования. В этом случае вряд ли бы вовсе метод makeRecord понадобился, но зато кто- то дальше обошелся бы приёмом лишь одного параметра.

Я уже не говорю и о том, что половина параметров избыточна и их можно было бы определить в наследнике класса Record.

## 1.4 Странные решения. Множество методов для решения одной и той же проблемы

Такую ситуацию я пронаблюдал со стороны, подглядывая за тимлидом. Оказывается, в C++ возможно распарсить строку во время двумя с половиной способами стандартной библиотеки и все способы работают неверно. Им становится плохо в случае високосных годов, а также с тридцатым или тридцать первым февраля. Это проблему решает библиотека Boost. А еще можно воспользоваться функционалом из Си. Там это как- то делается через вызов strptime, но способ не для слабонервных. Потребуется провести конвертацию в обе стороны, чтобы убедиться, что переданная строка валидна в качестве даты.

## 1.5 Метод возвращает слишком много параметров, больше, чем нужно вызывающему его компоненту

В такой ситуации явно нарушается SRP, по всей видимости метод делает всё сразу и используется по- разному в разных частях проекта. Такой метод нуждается в рефакторинге, который будет зависеть от контекста. Возможно, потребуется разделить функционал метода по нескольким методам, а быть может, потребуется расширить иерархию классов.
