
### Теория

Fuzzing тестирование, если говорить, простыми словами, проверяет, а не делает ли программа чего- то недопустимого.

Юнит тесты хороши, но они применимы в том случае, когда требуется проверить малое число случаев:
- верное исполнение заложенной бизнес логики;
- отработка краевых случаев;
- верная работа с исключениями
- и прочее в таком же духе.

Иными словами, при проведении юнит- тестирования, известно, какой должен получиться результат. Мудрецы и эксперты уже посчитали, что если программе подать на вход X, а на выходе получится Y, то это правильно и классно. Но что будет, если подать на вход программе не X, а Z? Вот бы можно было подать на вход все возможные значения и посмотреть, что программа с ними сделает...

К сожалению, пока что квантовые компьютеры не используются в кофемашинах и на них еще не портирован Skyrim, так что осуществить задуманное не получится в обозримом будущем. Но, можно хотя бы попробовать. В этом кроется смысл fuzzing тестирования.

Fuzzing тестирование подразумевает генерирование в базовом случае рандомных данных, которые затем подаются на вход программе. Вот и всё. В приницпе, обязательной целью проверка выходных данных не всегда является, иногда вполне достаточно того, чтобы программа работала не взирая на то, какой только "мусор" не поступает ей на вход.

С другой стороны иногда возможно сравнение результатов работы программы с "эталоном" или, по крайней мере с другой реализацией. Если обе реализации выдают идентичный результат- всё в порядке, но если результаты различаются- возникает причина расследовать такой случай.

### Отчёт

При организации fuzz тестирования я стал вникать в `atheris`, библиотеку для Python. Первой проблемой, с которой я столкнулся, стало то, что документация к библиотеке такая, будто это уже четвертая библиотека fuzzing-тестирования, которую я собираюсь освоить.

К примеру, вот такой код будет работать очень долго и скорее всего не покажет ничего стоящего:
``` python
import atheris


with atheris.instrument_imports():
  import sys


def TestOneInput(data):
  if data == b"Crash":
    raise RuntimeError("Crashed")


atheris.Setup(sys.argv, TestOneInput)
atheris.Fuzz()
```

Но если добавить декоратор к функции, внезапно, функция тестируется в мгновение:
``` python
@atheris.instrument_func
def TestOneInput(data):

  if data == b"Crash":
    raise RuntimeError("Crashed")
```

```
=== Uncaught Python exception: ===
RuntimeError: Crashed
Traceback (most recent call last):
  File "/home/yonder/Desktop/sandbox/app.py", line 12, in TestOneInput
    raise RuntimeError("Crashed")
RuntimeError: Crashed

==19376== ERROR: libFuzzer: fuzz target exited
SUMMARY: libFuzzer: fuzz target exited
MS: 2 CMP-CMP- DE: "\377\377\377\377"-"Crash"-; base unit: adc83b19e793491b1c6ea0fd8b46cd9f32e592fc
0x43,0x72,0x61,0x73,0x68,
Crash
artifact_prefix='./'; Test unit written to ./crash-7f971bce469e4980bbc9a77bc940fb107f0eb748
Base64: Q3Jhc2g=
```

Трезво оценив свои силы, я отказался от идеи тестировать свой проект на Django целиком. Вместо этого я сконцентрировал свое внимание на одной из вспомогательных функций, которая вычисляет расстояние между двумя точками за Земле. Получилось у меня написать такую тестовую функцию . Наверное, как- то можно настроить atheris так, чтобы он генерировал целые числа. Еще, наверное, как- то можно настроить ему пул начальных значений, от которых он смог бы отталкиваться, но пока что я с этим не успелразобраться.

``` python
import atheris
import random
from car_fleet.helpers.helpers import get_distance_between_points


with atheris.instrument_imports():
  import sys


def randomize(number):
    return number * random.random() * random.randint(-10, 10)


@atheris.instrument_func
def test_get_distance(data):
    p1 = int.from_bytes(data, 'big')
    p2 = randomize(p1)
    p3 = randomize(p1)
    p4 = randomize(p1)

    get_distance_between_points((p1, p2),(p3, p4))



atheris.Setup(sys.argv, test_get_distance)
atheris.Fuzz()
```

В ходе тестирования выяснилось, что, оказывается, можно нагенерировать такой большой int, что python не сможет его конвертировать во float:

```
    lat2 = llat2 * math.pi / 180.
           ~~~~~~^~~~~~~~~
OverflowError: int too large to convert to float
```

Еще мне встретилась такая ошибка, некорректное значение переменной `delta`.

```
    cdelta = math.cos(delta)
             ^^^^^^^^^^^^^^^
ValueError: math domain error
```

Иных ошибок мне встретить не удалось. Таким образом, моя функция на несколько десятков строк, которая вполне корректно себя вела, была сломана за милисекунды с помощью fuzzing - тестирования. А ведь это еще и при условии того, что я хотя бы на вход подаю значения верного типа.
