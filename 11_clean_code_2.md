2.1 Класс будет скорее всего слишком большим, если как раз таки был нарушен принцип SRP. Множество инстансов одного и того же класса могут свидетельствовать об ошибке проектирования. Множество инстансов демонстрируют, что функционал класса требуется в разных частях программы, тем самым выходит, что этот функционал "размазан" по программе, что в свою очередь может привести к проблемам в попытках избавиться от класса или модифицировать его.

2.2 Слишком маленький класс может получиться из- за чрезмерно атомарного деления на сущности в попытках удовлетворить SRP. А это приведет к тому, что думать о коде на третьем уровне будет сложнее, поскольку нужно будет в голове держать множество маленьких сущностей, а как мы знаем, кошелек Миллера имеет ограниченный размер.

2.3 Такое может происходить в результате ошибки рефакторинга, а может быть это настолько глубокое legacy, что никто не решается это исправить.

2.4 Ситуация, аналогичная пункту 2.1. Логика, предоставляемая классом, нужна сразу по всей программе, что плохо. Результатом того, что в класс попадают данные со всех мест в программе может стать ошибка с трудно выясняемой причиной. Помимо этого это свидетельствует о сильной связности кода.

2.5 Такая зависимость прямо противоречит ООП парадигме, поскольку классы должны торчать друг на друга интерфейсами, а внутренняя реализация должна быть и вовсе недоступна. Также такая ситуация возможна в тестах, когда тест полагается на свои знания о внутренней реализации класса. Это ошибочно, правильно - это сделать наследника класса со специальным интерфейсом, который затем можно использовать при тестировании.

2.6 Приведение родительских классов к дочерним может привести к NullReference Exception при попытке обратиться к существующему интерфейсу у потомка, но не у родителя. А еще может произойти так, что отработает не та реализация.

2.7 Это свидетельствует о сильной связности кода. Означает, что логика разбросана по нескольким классам.

2.8 В принципе, я такое допускаю в некоторых случаях. Но в общем случае можно считать, что наследование применено зря. Скорее всего не стоит и вовсе наследоваться от такого класса, чьи атрибуты не планируется использовать. Как говорилось в ООАП-2 **наследование - мощный способ переиспользования кода**.

3.1 Нарушен принцип SRP.

3.2 Эта ошибка свойственная ситуации, когда нет времени менять колеса с квадратных на круглые, потому что уже надо ехать. Плохой дизайн- следствие отсутствия размышлений о программе на третьем уровне, ошибку плохого дизайна приходится исправлять сложным витиеватым паттерном проектирования.
