# 1 Зависимость фреймворка

*В одном из приложений я реализовывал логику, похожую на round-robin: я вызывал функции, содержащиеся в коллекции. Я думаю, что зависимость в этой ситуации присутствует, но не явно. Она не видна до тех пор, пока всё штатно, но, например, если одна из функций сработает не так, как предполагалось- она может повлиять на цикл вызова.*

Таким образом, корректность работы компонента для вызова функций не влияет от вызываемых функций.

# 2 Зависимость расшаренного формата

*Продолжая ситуацию, описанную в пункте 1, я столкнулся и с такой зависимостью. Я разрешил её следующим образом: я определил формат данных в третьем месте, таким образом я перешел от неясной зависимости между читателем и писателем к явной зависимости их обоих от формата записи.*

Писатель и читатель не зависят друг от друга.

# 3. Зависимость зависимости

*В ходе реализации логирования в программе в stdout я предположил, что произойдет, если где-нибудь stdout программы поменяется. Это привело меня к решению изменить мой подход и не полагаться на глобальный stdout.*

Зависимость разрешается запретом на смену stdout'а программы. Но в рамках Linux это сложно осуществимо, поэтому следует избрать другой подход по реализации логирования.

# 4. Зависимость краша

С таким я не сталкивался и слабо представляю, как такое возможно.

# 5. Зависимость перебрасывания

*Зависимость такого рода является зависимостью, поскольку она влияет на поток исполнения кода. В одном из моих приложений я писал в БД, но в случае, если она была недоступна, приложение сохраняло информацию в файл. Приложение зависит первоначально от БД, но если база данных не доступна, зависимость от возможности писать в файл становится явной. Поскольку я могу сказать "из- за недоступности БД произошло это...", выходит, что приложение от БД зависит.*

Зависимость присутствует, с ней ничего не поделаешь, кроме как увеличить количество "узлов отказа".

# 6. Зависимость инверсии

*Я реализовывал инверсию зависимостей через обращение к атрибутам абстрактного класса, потомки которого выбирались посредством конфигурационного файла. Как избавиться от такой зависимости я не придумал.*

От неё защищает грамотно проработанная система типов.

# 7. Зависимость зацикливания

*Такая ситуация встречается мне при работе с ORM. В одном модуле программы я должен определить одни классы базы данных, в другом модуле другие классы, а чтобы связать их приходиться обходиться без импортирования имен, поскольку интерпретатор сразу же жалуется на циклический импорт. Вместо явного указания ссылки на классы применяется подход "написать вручную название класса".*

Проблема неразрешима в python, остается применять такой костыльный способ.

# 8. Зависимость высшего порядка

При использовании директивы

```python
from a import *
```

*Возможна ситуация, при которой в коде программы будет переопределено имя из модуля. Это скорее всего нарушит его работу. Я стараюсь не использовать такой импорт, но в случае чего линтер подсветит место переопределения в коде. Но в общем, линтер может и сам отключиться.*


Зависимость решается методом "Делай нормально - будет нормально".
# 9. Зависимость большинства

*Выходит так, что работа АЭС не явно зависит от каждой из пяти подсистем управления. Помимо этого может быть еще и неявная зависимость между разными реализациями- сеть передачи данных, сервис синхронизации времени и прочее.*

*Я сталкивался с похожей ситуацией, когда писал в кластер БД. Два из трех инстансов на отрез отказывались принимать мои данные. Хоть я и сотню раз к тому моменту успел удостовериться в их корректности. Оказалось, что проблема крылась в настройках MTU виртуальных интерфейсов ВМ, на которых находились два инстанса. Мои пакеты с данными были слишком велики для этих двух виртуальных машин и отбрасывались их интерфейсами.*

*Таким образом моя программа оказалась зависима от большинства.*

Моя программа зависит от коалиции большинства. Такая зависимость может быть разрешена с помощью увеличения числа участников голосования
